# Tutorial 1 - ezxml

0. Install required applications

- Install ESAN according to instruction on the main site
- Install other required applications: wget, xxd, gdb

1. Download ezxml 0.8.6
```
wget http://prdownloads.sourceforge.net/ezxml/ezxml-0.8.6.tar.gz
```

2. Unpack the source code
```
tar xvf ezxml-0.8.6.tar.gz
```

3. Enter the ezxml directory
```
cd ezxml
```

4. Compile test program
```
make test
```

5. Copy provided test files and maps into local directory
(ESAN_DIR is the directory where ESAN sources are available)
```
cp ESAN_DIR/doc/tutorial_000/*.map .
cp ESAN_DIR/doc/tutorial_000/*.xml .
```

6. Run test program on provided test file (without ESAN)
```
./ezxmltest test_000.xml
```

7. Setup settings for core dumps

```
ulimit -c unlimited
```
With root privileges run following command:
```
echo "core-%e-%s-%t" > /proc/sys/kernel/core_pattern
```

8. Analyze content of provided maps: `esan_always_succeed.map, 000.map, 001.map, 002.map, 003.map, 004.map`

You can see content of `esan_always_succeed.map` using following command:
```
xxd -b esan_always_succeed.map
```
N-th bit set to 1 causes n-th ESAN hook execution to fail.
When the input file contains split marker ("XXXX" string), first part of file (before split string) is used as ESAN error injection bitmap and the second part as input to tested program.

9. Run test program on provided test file (with ESAN) with map `esan_always_succeed.map`

(ESAN_DIR is the directory where ESAN sources are available)
```
AFL_USE_STDIO="Y" LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest test_000.xml < esan_always_succeed.map
```

You should receive following output from ESAN:
```
Error Sanitizer stats
--------------------|----------|-----------------
 Function           | nr execs | nr failed execs
--------------------|----------|-----------------
 malloc             |        4 |               0
 realloc            |        1 |               0
--------------------|----------|-----------------
 TOTAL              |        5 |               0
--------------------|----------|-----------------
```
9. Run test program on provided test file (with ESAN) with maps `map_000` to `map_004`

```
AFL_USE_STDIO="Y" LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest test_000.xml < 000.map
AFL_USE_STDIO="Y" LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest test_000.xml < 001.map
AFL_USE_STDIO="Y" LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest test_000.xml < 002.map
AFL_USE_STDIO="Y" LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest test_000.xml < 003.map
AFL_USE_STDIO="Y" LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest test_000.xml < 004.map
```

You should receive 4 messages:
```
Segmentation fault (core dumped)
```
and one normal execution:
```
<TAG1>VALUE</TAG1>

Error Sanitizer stats
--------------------|----------|-----------------
 Function           | nr execs | nr failed execs
--------------------|----------|-----------------
 malloc             |        4 |               0
 realloc            |        1 |               0
--------------------|----------|-----------------
 TOTAL              |        5 |               0
--------------------|----------|-----------------
```
This means that from 5 occurences of hooked functions, only 4 leads to crashes (are incorrectly handled).

10. List all generated core dumps
```
ls core*
```
You should receive names of 4 files similar to this (last part is time as nr seconds from start of the epoch):
```
core-ezxmltest-11-1590144414.14772  core-ezxmltest-11-1590144417.14773  core-ezxmltest-11-1590144419.14774  core-ezxmltest-11-1590144420.14775  core-ezxmltest-11-1590149275.16925
```

11. Run gdb analysis on each of cores
(use the name of core dumps from your list)
Run:
```
gdb ezxmltest core-ezxmltest-11-1590144414.14772
```
Enter following instruction to display backtrace:
```
backtrace
```
Enter following instruction to display full backtrace:
```
backtrace full
```

You should receive similar information for first core dump:
```
Core was generated by `./ezxmltest test_000.xml'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __memset_avx2 () at ../sysdeps/x86_64/multiarch/memset-avx2.S:135
135	../sysdeps/x86_64/multiarch/memset-avx2.S: No such file or directory.
(gdb) bt full
#0  __memset_avx2 () at ../sysdeps/x86_64/multiarch/memset-avx2.S:135
No locals.
#1  0x00000000004056ca in ezxml_new (name=0x0) at ezxml.c:838
        ent = {0x4067f6 "lt;", 0x4067fa "&#60;", 0x406800 "gt;", 0x406804 "&#62;", 0x40680a "quot;", 0x406810 "&#34;", 0x406816 "apos;", 0x40681c "&#39;", 0x406822 "amp;", 0x406827 "&#38;", 0x0}
        root = 0x0
#2  0x0000000000403329 in ezxml_parse_str (s=0x7fb8046a0000 <error: Cannot access memory at address 0x7fb8046a0000>, len=19) at ezxml.c:472
        root = 0x0
        q = 0 '\000'
        e = 0 '\000'
        d = 0x0
        attr = 0x0
        a = 0x0
        l = 0
        i = 0
        j = 0
#3  0x0000000000404238 in ezxml_parse_fd (fd=3) at ezxml.c:641
        root = 0x0
        st = {st_dev = 64512, st_ino = 17320621, st_nlink = 1, st_mode = 33204, st_uid = 1354804405, st_gid = 1354804405, __pad0 = 0, st_rdev = 0, st_size = 19, st_blksize = 4096,
          st_blocks = 8, st_atim = {tv_sec = 1590142728, tv_nsec = 76299248}, st_mtim = {tv_sec = 1590142724, tv_nsec = 760272098}, st_ctim = {tv_sec = 1590142724, tv_nsec = 760272098},
          __glibc_reserved = {0, 0, 0}}
        l = 4096
        m = 0x7fb8046a0000
#4  0x0000000000404338 in ezxml_parse_file (file=0x7ffe81a1ab11 "test_000.xml") at ezxml.c:659
        fd = 3
        xml = 0x0
#5  0x0000000000406283 in main (argc=2, argv=0x7ffe81a19218) at ezxml.c:1008
        xml = 0x7ffe81a19210
        s = 0x0
        i = 0
```
You can see in the source file what happened in ezxml.c:838.

Each of core dumps provide different (unique) crash cause - so you have identified 4 unique vulnerabilities!

Now we will perform fuzzing the binary using afl (American Fuzzy Lop):

13. Compile binary for afl

Change the compiler in `GNUmakefile` line 24 to the following afl wrapper (performing instrumentation required by the afl):
```
CC = afl-gcc
```
Recompile binary:

```
make clean
make test
```

14. Prepare fuzzing environment (input, output directory, first test file and environment variables):

(ESAN_DIR is the directory where ESAN compilation results are available)
```
mkdir testcase_dir
mkdir findings_dir
cp esan_always_succeed.map testcase_dir/test_000
cat test_000.xml >> testcase_dir/test_000
AFL_PRELOAD=ESAN_DIR/error_sanitizer_preload.so
AFL_NO_FORKSRV=1
```

15. Start fuzzing:
```
afl-fuzz -i testcase_dir/ -o findings_dir/ -m none ./ezxmltest @@
```

You should quickly see a lot of crashes found by afl.

Crashing testfiles are located in `findings_dir/crashes/`, while other testfiles are located in `findings_dir/queue/`.

To manualy analyze crashes run (change ... to the rest of the filename of the selected crash):
```
cp findings_dir/crashes/id\:00... crash_000.cur_input
LD_PRELOAD="ESAN_DIR/error_sanitizer_preload.so" ./ezxmltest crash_000.cur_input
```

16.

If you want to fuzz without changing the input file (only changing the map) use the following syntax:

```
AFL_USE_STDIO="Y" afl-fuzz -i testcase_dir/ -o findings_dir/ -m none ./ezxmltest test_000.xml
```

Fuzzing map will be provided to the ESAN using standard input.

